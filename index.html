<!DOCTYPE html>
<html>
<head>
    <title>TETRIS GAME</title>
    <style>
        /* * CSS (스타일)
         * - 게임 레이아웃 및 시각적 요소 정의
         */
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #2c3e50; /* 어두운 배경 */
            color: #ecf0f1;
            margin: 0;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 200px; /* 캔버스 영역과 사이드 패널 */
            gap: 20px;
            padding: 20px;
            background: #34495e;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #board {
            /* 300x600 크기에 맞춤 (10x20 블록, 각 30px) */
            border: 5px solid #bdc3c7;
            background-color: #2c3e50;
        }

        .side-panel {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .side-panel h1 {
            color: #f1c40f;
            text-align: center;
            margin-top: 0;
        }

        .side-panel p {
            font-size: 1.1em;
            margin: 0;
        }

        .side-panel span {
            font-weight: bold;
            color: #3498db;
        }

        #next-piece {
            border: 2px solid #3498db;
            padding: 10px;
            /* 다음 블록 캔버스가 들어갈 적절한 높이 설정 */
            height: 120px; 
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2c3e50;
            border-radius: 5px;
        }

        #next-canvas {
             /* 100x100 캔버스가 들어감 */
            background-color: #2c3e50;
        }

        button {
            padding: 10px 20px;
            font-size: 1.2em;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2ecc71;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="board" width="300" height="600"></canvas>
        
        <div class="side-panel">
            <h1>TETRIS</h1>
            <p>Score: <span id="score">0</span></p>
            <p>Lines: <span id="lines">0</span></p>
            <p>Level: <span id="level">1</span></p>
            <h3>NEXT</h3>
            <div id="next-piece">
                <canvas id="next-canvas" width="120" height="120"></canvas>
            </div>
            <button id="play-button">Start / Pause</button>

            <h4>Controls</h4>
            <ul>
                <li>Left/Right: 이동</li>
                <li>Down: 소프트 드롭</li>
                <li>Up / X: 회전</li>
                <li>Space: 하드 드롭</li>
            </ul>
        </div>
    </div>
    
    <script>
        /* * JavaScript (게임 로직)
         * - 1줄 클리어 시 250ms 동안 주황색으로 깜박인 후 줄이 제거되는 효과가 적용되었습니다.
         */
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');

        // 게임 설정
        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 30; 
        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        let requestId; // requestAnimationFrame ID
        let lastTime = 0;
        let dropCounter = 0;
        let dropInterval = 1000; // 1초마다 하강 (속도 조절 변수)
        let score = 0;
        let lines = 0;
        let level = 1;

        // HTML 요소
        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const levelElement = document.getElementById('level');
        const playButton = document.getElementById('play-button');

        // 블록 정의 (Tetrominoes)
        const SHAPES = [
            null, // 0번 인덱스는 빈 공간
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // 1: I
            [[2, 2], [2, 2]], // 2: O
            [[0, 3, 0], [3, 3, 3], [0, 0, 0]], // 3: T
            [[4, 0, 0], [4, 4, 4], [0, 0, 0]], // 4: L
            [[0, 0, 5], [5, 5, 5], [0, 0, 0]], // 5: J
            [[0, 6, 6], [6, 6, 0], [0, 0, 0]], // 6: S
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]  // 7: Z
        ];

        const COLORS = [
            '#000',      // 0: 배경
            '#00f0f0',   // 1: I (Cyan)
            '#f0f000',   // 2: O (Yellow)
            '#a000f0',   // 3: T (Purple)
            '#f0a000',   // 4: L (Orange)
            '#0000f0',   // 5: J (Blue)
            '#00f000',   // 6: S (Green)
            '#f00000',   // 7: Z (Red)
            '#FF8C00'    // 8: 클리어 효과 (Dark Orange - 250ms 동안 깜빡임)
        ];

        // 현재 움직이는 블록 상태
        let piece = {
            shape: [],
            x: 0,
            y: 0,
            colorIndex: 0
        };
        let nextPiece = newPiece(); // 다음에 나올 블록

        // ====================================================================
        // 헬퍼 함수
        // ====================================================================

        /**
         * 새로운 블록 상태 객체를 생성합니다.
         */
        function newPiece() {
            const randIndex = Math.floor(Math.random() * 7) + 1;
            const newShape = SHAPES[randIndex];
            const newPieceState = {
                shape: newShape,
                // 보드 중앙에 위치
                x: Math.floor(COLS / 2) - Math.floor(newShape[0].length / 2),
                y: 0,
                colorIndex: randIndex
            };
            return newPieceState;
        }

        /**
         * 현재 블록을 다음 블록으로 교체하고 새 다음 블록 생성 (등장)
         */
        function spawnPiece() {
            piece = nextPiece;
            nextPiece = newPiece();
            
            if (checkCollision(board, piece)) {
                // 게임 오버
                cancelAnimationFrame(requestId);
                requestId = null;
                alert('Game Over! Your Score: ' + score);
                
                // 보드 및 상태 초기화
                board = Array.from({ length: ROWS }, () => Array(COLS).fill(0)); 
                score = 0;
                lines = 0;
                level = 1;
                dropInterval = 1000;
                updateScore();
            }
            drawNextPiece();
        }

        /**
         * 충돌 검사
         */
        function checkCollision(currentBoard, currentPiece) {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const newX = currentPiece.x + x;
                        const newY = currentPiece.y + y;

                        // 1. 보드 경계를 벗어남 (좌우, 아래)
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        // 2. 이미 채워진 보드 셀과 충돌
                        if (newY >= 0 && currentBoard[newY][newX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * 현재 블록을 보드에 병합(고정)시킴
         */
        function mergePiece() {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        board[piece.y + y][piece.x + x] = piece.colorIndex;
                    }
                }
            }
        }

        /**
         * 지정된 시간(ms)만큼 비동기적으로 대기합니다.
         */
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        /**
         * 가득 찬 줄을 제거하고 점수를 업데이트 (깜빡임 효과 적용)
         */
        async function removeLines() {
            let linesToClear = [];

            // 1. 클리어할 줄 인덱스 수집
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    linesToClear.push(y);
                }
            }

            if (linesToClear.length > 0) {
                // 2. 클리어 효과 (주황색(8번 인덱스)으로 변경 및 250ms 지연)
                for (const y of linesToClear) {
                    board[y].fill(8); 
                }
                draw(); // 변경된 색상을 즉시 렌더링
                await sleep(250); // 250ms 동안 대기 (깜빡이는 시간)
                
                // 3. 실제 줄 제거 실행 및 점수 업데이트
                let linesCleared = linesToClear.length;
                
                // 줄 제거 로직 (인덱스 순서 주의: 아래쪽 줄부터 제거해야 인덱스가 꼬이지 않음)
                for (const y of linesToClear.reverse()) { 
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                }

                // 점수 계산 및 레벨업
                const points = [0, 40, 100, 300, 1200];
                score += points[linesCleared] * level;
                lines += linesCleared;
                
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    // 레벨업 시 속도 증가 (최소 100ms)
                    dropInterval = Math.max(100, 1000 - (level - 1) * 70); 
                }

                updateScore();
                draw(); // 최종 보드 상태 렌더링
            }
        }

        // ====================================================================
        // 렌더링 함수
        // ====================================================================

        /**
         * 캔버스에 사각형 블록을 그림
         */
        function drawBlock(x, y, colorIndex, context, offsetX = 0, offsetY = 0) {
            if (colorIndex === 0) return;
            context.fillStyle = COLORS[colorIndex];
            context.fillRect(
                x * BLOCK_SIZE + offsetX, 
                y * BLOCK_SIZE + offsetY, 
                BLOCK_SIZE, 
                BLOCK_SIZE
            );
            // 블록 테두리
            context.strokeStyle = '#2c3e50'; 
            context.strokeRect(
                x * BLOCK_SIZE + offsetX, 
                y * BLOCK_SIZE + offsetY, 
                BLOCK_SIZE, 
                BLOCK_SIZE
            );
        }

        /**
         * 메인 보드와 현재 블록을 그림
         */
        function draw() {
            // 1. 보드 전체 지우기
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. 보드에 고정된 블록 그리기
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    drawBlock(x, y, board[y][x], ctx);
                }
            }

            // 3. 현재 움직이는 블록 그리기
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        drawBlock(piece.x + x, piece.y + y, piece.colorIndex, ctx);
                    }
                }
            }
        }

        /**
         * 다음 블록을 그리는 함수
         */
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            const shape = nextPiece.shape;
            const size = shape.length;
            
            // 캔버스 중앙에 블록을 그리기 위한 오프셋 계산
            const startX = (nextCanvas.width - size * BLOCK_SIZE) / 2;
            const startY = (nextCanvas.height - size * BLOCK_SIZE) / 2;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (shape[y][x]) {
                        drawBlock(x, y, nextPiece.colorIndex, nextCtx, startX, startY);
                    }
                }
            }
        }

        // ====================================================================
        // 게임 루프 및 컨트롤러
        // ====================================================================

        /**
         * 블록 이동 및 회전 함수
         */
        function movePiece(dir, dy = 0, rotate = false) {
            let nextPieceState = { ...piece };
            
            if (rotate) {
                // 회전: 90도 시계 방향 회전
                const N = piece.shape.length;
                let newShape = Array.from({ length: N }, () => Array(N).fill(0));

                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        newShape[x][N - 1 - y] = piece.shape[y][x];
                    }
                }
                nextPieceState.shape = newShape;

                // Wall Kick (벽차기) - 간단한 구현: 회전 후 충돌하면 좌우로 이동 시도
                for (let offset = 0; offset < N; offset++) {
                    nextPieceState.x = piece.x + offset;
                    if (!checkCollision(board, nextPieceState)) {
                        piece = nextPieceState;
                        draw();
                        return;
                    }
                    nextPieceState.x = piece.x - offset;
                    if (!checkCollision(board, nextPieceState)) {
                        piece = nextPieceState;
                        draw();
                        return;
                    }
                    nextPieceState.x = piece.x; // 원위치
                }
                return;

            } else {
                // 이동
                nextPieceState.x += dir;
                nextPieceState.y += dy;
            }

            if (!checkCollision(board, nextPieceState)) {
                piece = nextPieceState;
            } else if (dy !== 0) {
                // 아래로 이동 중 충돌 발생 = 착지
                mergePiece();
                // 비동기 함수 호출 (await 사용하지 않아 게임 흐름 유지)
                removeLines(); 
                spawnPiece();
            }
            draw();
        }

        /**
         * 게임 루프 (Drop)
         */
        function drop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                movePiece(0, 1); // 블록 하강
                dropCounter = 0;
            }

            draw();
            requestId = requestAnimationFrame(drop);
        }

        /**
         * 사용자 입력 처리
         */
        document.addEventListener('keydown', event => {
            if (!requestId) return; // 게임 일시 정지 상태에서는 작동하지 않음

            switch (event.key) {
                case 'ArrowLeft':
                    movePiece(-1, 0); // 왼쪽 이동
                    break;
                case 'ArrowRight':
                    movePiece(1, 0); // 오른쪽 이동
                    break;
                case 'ArrowDown':
                    // 소프트 드롭 (일시적으로 하강 속도 높임)
                    movePiece(0, 1);
                    dropCounter = 0; // 빠른 하강 후 드롭 카운터 초기화
                    break;
                case 'ArrowUp':
                case 'x':
                    movePiece(0, 0, true); // 회전
                    break;
                case ' ':
                    // 하드 드롭 (즉시 바닥으로 이동)
                    while (!checkCollision(board, { ...piece, y: piece.y + 1 })) {
                        piece.y++;
                    }
                    movePiece(0, 1); // 최종 착지 및 병합
                    break;
            }
        });

        /**
         * 점수/라인/레벨 표시 업데이트
         */
        function updateScore() {
            scoreElement.innerText = score;
            linesElement.innerText = lines;
            levelElement.innerText = level;
        }

        /**
         * 게임 시작/일시 정지 토글
         */
        function play() {
            if (requestId) {
                // 게임 일시 정지
                cancelAnimationFrame(requestId);
                requestId = null;
                playButton.innerText = 'Resume';
            } else {
                // 게임 시작 또는 재개
                if (!piece.shape || piece.shape.length === 0) {
                     spawnPiece();
                }
                requestId = requestAnimationFrame(drop);
                playButton.innerText = 'Pause';
            }
        }

        // ====================================================================
        // 초기화
        // ====================================================================

        // 초기 시작 버튼 이벤트 리스너 설정
        playButton.addEventListener('click', play);

        // 초기 점수 및 다음 블록 표시
        updateScore();
        drawNextPiece();
    </script>
</body>
</html>
