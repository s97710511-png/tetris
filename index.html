<!DOCTYPE html>
<html>
<head>
    <title>TETRIS GAME</title>
    <style>
        /* * CSS (스타일)
         * - 게임 레이아웃 및 시각적 요소 정의
         */
        body {
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #2c3e50; /* 어두운 배경 */
            color: #ecf0f1;
            margin: 0;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 200px; /* 캔버스 영역과 사이드 패널 */
            gap: 20px;
            padding: 20px;
            background: #34495e;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        #board {
            border: 5px solid #bdc3c7;
            background-color: #2c3e50;
        }

        .side-panel {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .side-panel h1 {
            color: #f1c40f;
            text-align: center;
            margin-top: 0;
        }

        .side-panel p {
            font-size: 1.1em;
            margin: 0;
        }

        .side-panel span {
            font-weight: bold;
            color: #3498db;
        }

        #next-piece {
            border: 2px solid #3498db;
            padding: 10px;
            height: 80px;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #2c3e50;
            border-radius: 5px;
        }

        button {
            padding: 10px 20px;
            font-size: 1.2em;
            background-color: #27ae60;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2ecc71;
        }
    </style>
</head>
<body>
    <div class="container">
        <canvas id="board" width="300" height="600"></canvas>
        
        <div class="side-panel">
            <h1>TETRIS</h1>
            <p>Score: <span id="score">0</span></p>
            <p>Lines: <span id="lines">0</span></p>
            <p>Level: <span id="level">0</span></p>
            <h3>NEXT</h3>
            <div id="next-piece">
                 <canvas id="next-canvas" width="100" height="100"></canvas>
            </div>
            <button id="play-button">Start / Pause</button>
        </div>
    </div>
    
    <script>
        /* * JavaScript (게임 로직)
         * - Canvas API를 이용한 렌더링 및 게임 규칙 구현
         */
        const canvas = document.getElementById('board');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('next-canvas');
        const nextCtx = nextCanvas.getContext('2d');

        // 게임 설정
        const ROWS = 20;
        const COLS = 10;
        const BLOCK_SIZE = 30; // 300px / 10 = 30px
        let board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
        let requestId;
        let lastTime = 0;
        let dropCounter = 0;
        let dropInterval = 1000; // 1초마다 하강
        let score = 0;
        let lines = 0;
        let level = 1;

        // 점수 및 레벨 업데이트
        const scoreElement = document.getElementById('score');
        const linesElement = document.getElementById('lines');
        const levelElement = document.getElementById('level');
        const playButton = document.getElementById('play-button');

        // 블록 정의 (Tetrominoes)
        // 블록 모양 배열 및 색상 (1번 인덱스부터 사용)
        const SHAPES = [
            null, // 0번 인덱스는 빈 공간
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
            [[2, 2], [2, 2]], // O
            [[0, 3, 0], [3, 3, 3], [0, 0, 0]], // T
            [[4, 0, 0], [4, 4, 4], [0, 0, 0]], // L
            [[0, 0, 5], [5, 5, 5], [0, 0, 0]], // J
            [[0, 6, 6], [6, 6, 0], [0, 0, 0]], // S
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]]  // Z
        ];

        const COLORS = [
            '#000',      // 0: 배경
            '#00f0f0',   // 1: I (Cyan)
            '#f0f000',   // 2: O (Yellow)
            '#a000f0',   // 3: T (Purple)
            '#f0a000',   // 4: L (Orange)
            '#0000f0',   // 5: J (Blue)
            '#00f000',   // 6: S (Green)
            '#f00000'    // 7: Z (Red)
        ];

        // 현재 움직이는 블록 상태
        let piece = {
            shape: [],
            x: 0,
            y: 0,
            colorIndex: 0
        };
        let nextPiece = newPiece(); // 다음에 나올 블록

        /**
         * 새로운 블록을 생성하고 다음 블록을 현재 블록으로 설정
         */
        function newPiece() {
            // 1부터 7까지 랜덤 블록 인덱스
            const randIndex = Math.floor(Math.random() * 7) + 1;
            const newShape = SHAPES[randIndex];
            const newPieceState = {
                shape: newShape,
                x: Math.floor(COLS / 2) - Math.floor(newShape[0].length / 2),
                y: 0,
                colorIndex: randIndex
            };
            return newPieceState;
        }

        /**
         * 현재 블록을 다음 블록으로 교체하고 새 다음 블록 생성
         */
        function spawnPiece() {
            piece = nextPiece;
            nextPiece = newPiece();
            
            // 초기 위치에 블록을 놓을 수 없으면 게임 오버
            if (checkCollision(board, piece)) {
                cancelAnimationFrame(requestId);
                alert('Game Over! Your Score: ' + score);
                board = Array.from({ length: ROWS }, () => Array(COLS).fill(0)); // 보드 초기화
                score = 0;
                lines = 0;
                level = 1;
                dropInterval = 1000;
                updateScore();
            }
            drawNextPiece();
        }

        /**
         * 캔버스에 사각형 블록을 그림
         * @param {number} x - 보드 X 좌표
         * @param {number} y - 보드 Y 좌표
         * @param {number} colorIndex - 블록 색상 인덱스
         * @param {CanvasRenderingContext2D} context - 그릴 캔버스 컨텍스트
         * @param {number} offsetX - X축 오프셋 (픽셀)
         * @param {number} offsetY - Y축 오프셋 (픽셀)
         */
        function drawBlock(x, y, colorIndex, context, offsetX = 0, offsetY = 0) {
            if (colorIndex === 0) return;
            context.fillStyle = COLORS[colorIndex];
            context.fillRect(
                x * BLOCK_SIZE + offsetX, 
                y * BLOCK_SIZE + offsetY, 
                BLOCK_SIZE, 
                BLOCK_SIZE
            );
            // 블록 테두리
            context.strokeStyle = '#2c3e50'; 
            context.strokeRect(
                x * BLOCK_SIZE + offsetX, 
                y * BLOCK_SIZE + offsetY, 
                BLOCK_SIZE, 
                BLOCK_SIZE
            );
        }

        /**
         * 보드와 현재 블록을 그림
         */
        function draw() {
            // 1. 보드 전체 지우기
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 2. 보드에 고정된 블록 그리기
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    drawBlock(x, y, board[y][x], ctx);
                }
            }

            // 3. 현재 움직이는 블록 그리기
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        drawBlock(piece.x + x, piece.y + y, piece.colorIndex, ctx);
                    }
                }
            }
        }

        /**
         * 다음 블록을 그리는 함수
         */
        function drawNextPiece() {
            nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            const shape = nextPiece.shape;
            const size = shape.length;
            
            // 캔버스 중앙에 블록을 그리기 위한 오프셋 계산
            const startX = (nextCanvas.width - size * BLOCK_SIZE) / 2;
            const startY = (nextCanvas.height - size * BLOCK_SIZE) / 2;

            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    if (shape[y][x]) {
                        drawBlock(x, y, nextPiece.colorIndex, nextCtx, startX, startY);
                    }
                }
            }
        }

        /**
         * 블록과 보드 간의 충돌 검사
         * @param {Array<Array<number>>} currentBoard - 보드 상태
         * @param {object} currentPiece - 현재 블록 상태
         * @returns {boolean} 충돌 발생 여부
         */
        function checkCollision(currentBoard, currentPiece) {
            for (let y = 0; y < currentPiece.shape.length; y++) {
                for (let x = 0; x < currentPiece.shape[y].length; x++) {
                    if (currentPiece.shape[y][x]) {
                        const newX = currentPiece.x + x;
                        const newY = currentPiece.y + y;

                        // 1. 보드 경계를 벗어남 (좌우, 아래)
                        if (newX < 0 || newX >= COLS || newY >= ROWS) {
                            return true;
                        }
                        // 2. 이미 채워진 보드 셀과 충돌 (윗쪽 경계는 무시, 0 미만은 항상 통과)
                        if (newY >= 0 && currentBoard[newY][newX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        /**
         * 현재 블록을 보드에 병합(고정)시킴
         */
        function mergePiece() {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        board[piece.y + y][piece.x + x] = piece.colorIndex;
                    }
                }
            }
        }

        /**
         * 가득 찬 줄을 제거하고 점수를 업데이트
         */
        function removeLines() {
            let linesCleared = 0;
            for (let y = ROWS - 1; y >= 0; y--) {
                // 현재 행이 모두 채워졌는지 확인
                if (board[y].every(cell => cell !== 0)) {
                    // 줄 제거: 해당 줄을 제거하고 위에 빈 줄을 추가
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    y++; // 줄이 제거되었으므로 인덱스를 다시 확인
                }
            }

            if (linesCleared > 0) {
                // 점수 계산 (테트리스 공식 사용: 레벨의 영향을 받음)
                const points = [0, 40, 100, 300, 1200];
                score += points[linesCleared] * level;
                lines += linesCleared;
                
                // 레벨업 조건 확인 (예: 10줄마다 레벨업)
                const newLevel = Math.floor(lines / 10) + 1;
                if (newLevel > level) {
                    level = newLevel;
                    dropInterval = Math.max(100, 1000 - (level - 1) * 70); // 속도 증가 (최소 100ms)
                }

                updateScore();
            }
        }

        /**
         * 블록 이동 및 회전 함수
         * @param {number} dir - 방향 (x축 이동: -1 좌, 1 우. 0: 하강)
         * @param {number} dy - y축 이동 (하강: 1)
         * @param {boolean} rotate - 회전 여부
         */
        function movePiece(dir, dy = 0, rotate = false) {
            let nextPieceState = { ...piece };
            
            if (rotate) {
                // 회전: 90도 시계 방향 회전
                const N = piece.shape.length;
                let newShape = Array.from({ length: N }, () => Array(N).fill(0));

                for (let y = 0; y < N; y++) {
                    for (let x = 0; x < N; x++) {
                        newShape[x][N - 1 - y] = piece.shape[y][x];
                    }
                }
                nextPieceState.shape = newShape;

                // Wall Kick (벽차기) - 간단한 구현
                // 회전 후 충돌하면 좌우로 이동 시도
                for (let offset = 0; offset < N; offset++) {
                    nextPieceState.x = piece.x + offset;
                    if (!checkCollision(board, nextPieceState)) {
                        piece = nextPieceState;
                        draw();
                        return;
                    }
                    nextPieceState.x = piece.x - offset;
                    if (!checkCollision(board, nextPieceState)) {
                        piece = nextPieceState;
                        draw();
                        return;
                    }
                    nextPieceState.x = piece.x; // 원위치
                }
                // 회전 실패: 아무것도 하지 않음
                return;

            } else {
                // 이동
                nextPieceState.x += dir;
                nextPieceState.y += dy;
            }

            if (!checkCollision(board, nextPieceState)) {
                piece = nextPieceState;
            } else if (dy !== 0) {
                // 아래로 이동 중 충돌 발생 = 착지
                mergePiece();
                removeLines();
                spawnPiece();
            }
            draw();
        }

        /**
         * 게임 루프 (Drop)
         * @param {number} time - requestAnimationFrame의 타임스탬프
         */
        function drop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                movePiece(0, 1); // 블록 하강
                dropCounter = 0;
            }

            draw();
            requestId = requestAnimationFrame(drop);
        }

        /**
         * 사용자 입력 처리
         */
        document.addEventListener('keydown', event => {
            if (!requestId) return; // 게임 일시 정지 상태에서는 작동하지 않음

            switch (event.key) {
                case 'ArrowLeft':
                    movePiece(-1, 0); // 왼쪽 이동
                    break;
                case 'ArrowRight':
                    movePiece(1, 0); // 오른쪽 이동
                    break;
                case 'ArrowDown':
                    // 소프트 드롭 (일시적으로 하강 속도 높임)
                    movePiece(0, 1);
                    dropCounter = 0; // 빠른 하강 후 드롭 카운터 초기화
                    break;
                case 'ArrowUp':
                case 'x':
                    movePiece(0, 0, true); // 회전
                    break;
                case ' ':
                    // 하드 드롭 (즉시 바닥으로 이동)
                    while (!checkCollision(board, { ...piece, y: piece.y + 1 })) {
                        piece.y++;
                    }
                    movePiece(0, 1); // 최종 착지 및 병합
                    break;
            }
        });

        /**
         * 점수/라인/레벨 표시 업데이트
         */
        function updateScore() {
            scoreElement.innerText = score;
            linesElement.innerText = lines;
            levelElement.innerText = level;
        }

        /**
         * 게임 시작/일시 정지 토글
         */
        function play() {
            if (requestId) {
                // 게임 일시 정지
                cancelAnimationFrame(requestId);
                requestId = null;
                playButton.innerText = 'Resume';
            } else {
                // 게임 시작 또는 재개
                spawnPiece();
                requestId = requestAnimationFrame(drop);
                playButton.innerText = 'Pause';
            }
        }

        // 초기 시작 버튼 이벤트 리스너 설정
        playButton.addEventListener('click', play);

        // 초기 점수 및 다음 블록 표시
        updateScore();
        drawNextPiece(); 
        
    </script>
</body>
</html>
